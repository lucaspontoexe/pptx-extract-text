{"version":3,"file":"bundle.js","sources":["F:/Lucas/dev stuff/pptx-to-txt/node_modules/svelte/internal/index.mjs","F:/Lucas/dev stuff/pptx-to-txt/node_modules/uzip/UZIP.js","F:/Lucas/dev stuff/pptx-to-txt/src/Convert.svelte","F:/Lucas/dev stuff/pptx-to-txt/src/main.ts"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot_spread(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_spread_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_spread_changes_fn(dirty) | get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            const remove = [];\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j++];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            for (let k = 0; k < remove.length; k++) {\n                node.removeAttribute(remove[k]);\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(anchor = null) {\n        this.a = anchor;\n        this.e = this.n = null;\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.h(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            info.blocks[i] = null;\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${String(value).replace(/\"/g, '&#34;').replace(/'/g, '&#39;')}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, options = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, options);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n        const new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n            on_destroy.push(...new_on_destroy);\n        }\n        else {\n            // Edge case - component was destroyed immediately,\n            // most likely as a result of a binding initialising\n            run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n    });\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const prop_values = options.props || {};\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : []),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, prop_values, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.31.1' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to seperate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_custom_elements_slots, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, update_slot, update_slot_spread, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","\r\n\r\nvar UZIP = {};\r\nif(typeof module == \"object\") module.exports = UZIP;\r\n\r\n\r\nUZIP[\"parse\"] = function(buf, onlyNames)\t// ArrayBuffer\r\n{\r\n\tvar rUs = UZIP.bin.readUshort, rUi = UZIP.bin.readUint, o = 0, out = {};\r\n\tvar data = new Uint8Array(buf);\r\n\tvar eocd = data.length-4;\r\n\t\r\n\twhile(rUi(data, eocd)!=0x06054b50) eocd--;\r\n\t\r\n\tvar o = eocd;\r\n\to+=4;\t// sign  = 0x06054b50\r\n\to+=4;  // disks = 0;\r\n\tvar cnu = rUs(data, o);  o+=2;\r\n\tvar cnt = rUs(data, o);  o+=2;\r\n\t\t\t\r\n\tvar csize = rUi(data, o);  o+=4;\r\n\tvar coffs = rUi(data, o);  o+=4;\r\n\t\r\n\to = coffs;\r\n\tfor(var i=0; i<cnu; i++)\r\n\t{\r\n\t\tvar sign = rUi(data, o);  o+=4;\r\n\t\to += 4;  // versions;\r\n\t\to += 4;  // flag + compr\r\n\t\to += 4;  // time\r\n\t\t\r\n\t\tvar crc32 = rUi(data, o);  o+=4;\r\n\t\tvar csize = rUi(data, o);  o+=4;\r\n\t\tvar usize = rUi(data, o);  o+=4;\r\n\t\t\r\n\t\tvar nl = rUs(data, o), el = rUs(data, o+2), cl = rUs(data, o+4);  o += 6;  // name, extra, comment\r\n\t\to += 8;  // disk, attribs\r\n\t\t\r\n\t\tvar roff = rUi(data, o);  o+=4;\r\n\t\to += nl + el + cl;\r\n\t\t\r\n\t\tUZIP._readLocal(data, roff, out, csize, usize, onlyNames);\r\n\t}\r\n\t//console.log(out);\r\n\treturn out;\r\n}\r\n\r\nUZIP._readLocal = function(data, o, out, csize, usize, onlyNames)\r\n{\r\n\tvar rUs = UZIP.bin.readUshort, rUi = UZIP.bin.readUint;\r\n\tvar sign  = rUi(data, o);  o+=4;\r\n\tvar ver   = rUs(data, o);  o+=2;\r\n\tvar gpflg = rUs(data, o);  o+=2;\r\n\t//if((gpflg&8)!=0) throw \"unknown sizes\";\r\n\tvar cmpr  = rUs(data, o);  o+=2;\r\n\t\r\n\tvar time  = rUi(data, o);  o+=4;\r\n\t\r\n\tvar crc32 = rUi(data, o);  o+=4;\r\n\t//var csize = rUi(data, o);  o+=4;\r\n\t//var usize = rUi(data, o);  o+=4;\r\n\to+=8;\r\n\t\t\r\n\tvar nlen  = rUs(data, o);  o+=2;\r\n\tvar elen  = rUs(data, o);  o+=2;\r\n\t\t\r\n\tvar name =  UZIP.bin.readUTF8(data, o, nlen);  o+=nlen;  //console.log(name);\r\n\to += elen;\r\n\t\t\t\r\n\t//console.log(sign.toString(16), ver, gpflg, cmpr, crc32.toString(16), \"csize, usize\", csize, usize, nlen, elen, name, o);\r\n\tif(onlyNames) {  out[name]={size:usize, csize:csize};  return;  }   \r\n\tvar file = new Uint8Array(data.buffer, o);\r\n\tif(false) {}\r\n\telse if(cmpr==0) out[name] = new Uint8Array(file.buffer.slice(o, o+csize));\r\n\telse if(cmpr==8) {\r\n\t\tvar buf = new Uint8Array(usize);  UZIP.inflateRaw(file, buf);\r\n\t\t/*var nbuf = pako[\"inflateRaw\"](file);\r\n\t\tif(usize>8514000) {\r\n\t\t\t//console.log(PUtils.readASCII(buf , 8514500, 500));\r\n\t\t\t//console.log(PUtils.readASCII(nbuf, 8514500, 500));\r\n\t\t}\r\n\t\tfor(var i=0; i<buf.length; i++) if(buf[i]!=nbuf[i]) {  console.log(buf.length, nbuf.length, usize, i);  throw \"e\";  }\r\n\t\t*/\r\n\t\tout[name] = buf;\r\n\t}\r\n\telse throw \"unknown compression method: \"+cmpr;\r\n}\r\n\r\nUZIP.inflateRaw = function(file, buf) {  return UZIP.F.inflate(file, buf);  }\r\nUZIP.inflate    = function(file, buf) { \r\n\tvar CMF = file[0], FLG = file[1];\r\n\tvar CM = (CMF&15), CINFO = (CMF>>>4);\r\n\t//console.log(CM, CINFO,CMF,FLG);\r\n\treturn UZIP.inflateRaw(new Uint8Array(file.buffer, file.byteOffset+2, file.length-6), buf);  \r\n}\r\nUZIP.deflate    = function(data, opts/*, buf, off*/) {\r\n\tif(opts==null) opts={level:6};\r\n\tvar off=0, buf=new Uint8Array(50+Math.floor(data.length*1.1));\r\n\tbuf[off]=120;  buf[off+1]=156;  off+=2;\r\n\toff = UZIP.F.deflateRaw(data, buf, off, opts.level);\r\n\tvar crc = UZIP.adler(data, 0, data.length);\r\n\tbuf[off+0]=((crc>>>24)&255); \r\n\tbuf[off+1]=((crc>>>16)&255); \r\n\tbuf[off+2]=((crc>>> 8)&255); \r\n\tbuf[off+3]=((crc>>> 0)&255); \t\r\n\treturn new Uint8Array(buf.buffer, 0, off+4);\r\n}\r\nUZIP.deflateRaw = function(data, opts) {\r\n\tif(opts==null) opts={level:6};\r\n\tvar buf=new Uint8Array(50+Math.floor(data.length*1.1));\r\n\tvar off = UZIP.F.deflateRaw(data, buf, off, opts.level);\r\n\treturn new Uint8Array(buf.buffer, 0, off);\r\n}\r\n\r\n\r\nUZIP.encode = function(obj, noCmpr) {\r\n\tif(noCmpr==null) noCmpr=false;\r\n\tvar tot = 0, wUi = UZIP.bin.writeUint, wUs = UZIP.bin.writeUshort;\r\n\tvar zpd = {};\r\n\tfor(var p in obj) {  var cpr = !UZIP._noNeed(p) && !noCmpr, buf = obj[p], crc = UZIP.crc.crc(buf,0,buf.length); \r\n\t\tzpd[p] = {  cpr:cpr, usize:buf.length, crc:crc, file: (cpr ? UZIP.deflateRaw(buf) : buf)  };  }\r\n\t\r\n\tfor(var p in zpd) tot += zpd[p].file.length + 30 + 46 + 2*UZIP.bin.sizeUTF8(p);\r\n\ttot +=  22;\r\n\t\r\n\tvar data = new Uint8Array(tot), o = 0;\r\n\tvar fof = []\r\n\t\r\n\tfor(var p in zpd) {\r\n\t\tvar file = zpd[p];  fof.push(o);\r\n\t\to = UZIP._writeHeader(data, o, p, file, 0);\r\n\t}\r\n\tvar i=0, ioff = o;\r\n\tfor(var p in zpd) {\r\n\t\tvar file = zpd[p];  fof.push(o);\r\n\t\to = UZIP._writeHeader(data, o, p, file, 1, fof[i++]);\t\t\r\n\t}\r\n\tvar csize = o-ioff;\r\n\t\r\n\twUi(data, o, 0x06054b50);  o+=4;\r\n\to += 4;  // disks\r\n\twUs(data, o, i);  o += 2;\r\n\twUs(data, o, i);  o += 2;\t// number of c d records\r\n\twUi(data, o, csize);  o += 4;\r\n\twUi(data, o, ioff );  o += 4;\r\n\to += 2;\r\n\treturn data.buffer;\r\n}\r\n// no need to compress .PNG, .ZIP, .JPEG ....\r\nUZIP._noNeed = function(fn) {  var ext = fn.split(\".\").pop().toLowerCase();  return \"png,jpg,jpeg,zip\".indexOf(ext)!=-1;  }\r\n\r\nUZIP._writeHeader = function(data, o, p, obj, t, roff)\r\n{\r\n\tvar wUi = UZIP.bin.writeUint, wUs = UZIP.bin.writeUshort;\r\n\tvar file = obj.file;\r\n\t\r\n\twUi(data, o, t==0 ? 0x04034b50 : 0x02014b50);  o+=4; // sign\r\n\tif(t==1) o+=2;  // ver made by\r\n\twUs(data, o, 20);  o+=2;\t// ver\r\n\twUs(data, o,  0);  o+=2;    // gflip\r\n\twUs(data, o,  obj.cpr?8:0);  o+=2;\t// cmpr\r\n\t\t\r\n\twUi(data, o,  0);  o+=4;\t// time\t\t\r\n\twUi(data, o, obj.crc);  o+=4;\t// crc32\r\n\twUi(data, o, file.length);  o+=4;\t// csize\r\n\twUi(data, o, obj.usize);  o+=4;\t// usize\r\n\t\t\r\n\twUs(data, o, UZIP.bin.sizeUTF8(p));  o+=2;\t// nlen\r\n\twUs(data, o, 0);  o+=2;\t// elen\r\n\t\r\n\tif(t==1) {\r\n\t\to += 2;  // comment length\r\n\t\to += 2;  // disk number\r\n\t\to += 6;  // attributes\r\n\t\twUi(data, o, roff);  o+=4;\t// usize\r\n\t}\r\n\tvar nlen = UZIP.bin.writeUTF8(data, o, p);  o+= nlen;\t\r\n\tif(t==0) {  data.set(file, o);  o += file.length;  }\r\n\treturn o;\r\n}\r\n\r\n\r\n\r\n\r\n\r\nUZIP.crc = {\r\n\ttable : ( function() {\r\n\t   var tab = new Uint32Array(256);\r\n\t   for (var n=0; n<256; n++) {\r\n\t\t\tvar c = n;\r\n\t\t\tfor (var k=0; k<8; k++) {\r\n\t\t\t\tif (c & 1)  c = 0xedb88320 ^ (c >>> 1);\r\n\t\t\t\telse        c = c >>> 1;\r\n\t\t\t}\r\n\t\t\ttab[n] = c;  }    \r\n\t\treturn tab;  })(),\r\n\tupdate : function(c, buf, off, len) {\r\n\t\tfor (var i=0; i<len; i++)  c = UZIP.crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);\r\n\t\treturn c;\r\n\t},\r\n\tcrc : function(b,o,l)  {  return UZIP.crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }\r\n}\r\nUZIP.adler = function(data,o,len) {\r\n\tvar a = 1, b = 0;\r\n\tvar off = o, end=o+len;\r\n\twhile(off<end) {\r\n\t\tvar eend = Math.min(off+5552, end);\r\n\t\twhile(off<eend) {\r\n\t\t\ta += data[off++];\r\n\t\t\tb += a;\r\n\t\t}\r\n\t\ta=a%65521;\r\n\t\tb=b%65521;\r\n\t}\r\n    return (b << 16) | a;\r\n}\r\n\r\nUZIP.bin = {\r\n\treadUshort : function(buff,p)  {  return (buff[p]) | (buff[p+1]<<8);  },\r\n\twriteUshort: function(buff,p,n){  buff[p] = (n)&255;  buff[p+1] = (n>>8)&255;  },\r\n\treadUint   : function(buff,p)  {  return (buff[p+3]*(256*256*256)) + ((buff[p+2]<<16) | (buff[p+1]<< 8) | buff[p]);  },\r\n\twriteUint  : function(buff,p,n){  buff[p]=n&255;  buff[p+1]=(n>>8)&255;  buff[p+2]=(n>>16)&255;  buff[p+3]=(n>>24)&255;  },\r\n\treadASCII  : function(buff,p,l){  var s = \"\";  for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);  return s;    },\r\n\twriteASCII : function(data,p,s){  for(var i=0; i<s.length; i++) data[p+i] = s.charCodeAt(i);  },\r\n\tpad : function(n) { return n.length < 2 ? \"0\" + n : n; },\r\n\treadUTF8 : function(buff, p, l) {\r\n\t\tvar s = \"\", ns;\r\n\t\tfor(var i=0; i<l; i++) s += \"%\" + UZIP.bin.pad(buff[p+i].toString(16));\r\n\t\ttry {  ns = decodeURIComponent(s); }\r\n\t\tcatch(e) {  return UZIP.bin.readASCII(buff, p, l);  }\r\n\t\treturn  ns;\r\n\t},\r\n\twriteUTF8 : function(buff, p, str) {\r\n\t\tvar strl = str.length, i=0;\r\n\t\tfor(var ci=0; ci<strl; ci++)\r\n\t\t{\r\n\t\t\tvar code = str.charCodeAt(ci);\r\n\t\t\tif     ((code&(0xffffffff-(1<< 7)+1))==0) {  buff[p+i] = (     code     );  i++;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<11)+1))==0) {  buff[p+i] = (192|(code>> 6));  buff[p+i+1] = (128|((code>> 0)&63));  i+=2;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<16)+1))==0) {  buff[p+i] = (224|(code>>12));  buff[p+i+1] = (128|((code>> 6)&63));  buff[p+i+2] = (128|((code>>0)&63));  i+=3;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<21)+1))==0) {  buff[p+i] = (240|(code>>18));  buff[p+i+1] = (128|((code>>12)&63));  buff[p+i+2] = (128|((code>>6)&63));  buff[p+i+3] = (128|((code>>0)&63)); i+=4;  }\r\n\t\t\telse throw \"e\";\r\n\t\t}\r\n\t\treturn i;\r\n\t},\r\n\tsizeUTF8 : function(str) {\r\n\t\tvar strl = str.length, i=0;\r\n\t\tfor(var ci=0; ci<strl; ci++)\r\n\t\t{\r\n\t\t\tvar code = str.charCodeAt(ci);\r\n\t\t\tif     ((code&(0xffffffff-(1<< 7)+1))==0) {  i++ ;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<11)+1))==0) {  i+=2;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<16)+1))==0) {  i+=3;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<21)+1))==0) {  i+=4;  }\r\n\t\t\telse throw \"e\";\r\n\t\t}\r\n\t\treturn i;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\nUZIP.F = {};\r\n\r\nUZIP.F.deflateRaw = function(data, out, opos, lvl) {\t\r\n\tvar opts = [\r\n\t/*\r\n\t\t ush good_length; /* reduce lazy search above this match length \r\n\t\t ush max_lazy;    /* do not perform lazy search above this match length \r\n         ush nice_length; /* quit search above this match length \r\n\t*/\r\n\t/*      good lazy nice chain */\r\n\t/* 0 */ [ 0,   0,   0,    0,0],  /* store only */\r\n\t/* 1 */ [ 4,   4,   8,    4,0], /* max speed, no lazy matches */\r\n\t/* 2 */ [ 4,   5,  16,    8,0],\r\n\t/* 3 */ [ 4,   6,  16,   16,0],\r\n\r\n\t/* 4 */ [ 4,  10,  16,   32,0],  /* lazy matches */\r\n\t/* 5 */ [ 8,  16,  32,   32,0],\r\n\t/* 6 */ [ 8,  16, 128,  128,0],\r\n\t/* 7 */ [ 8,  32, 128,  256,0],\r\n\t/* 8 */ [32, 128, 258, 1024,1],\r\n\t/* 9 */ [32, 258, 258, 4096,1]]; /* max compression */\r\n\t\r\n\tvar opt = opts[lvl];\r\n\t\r\n\t\r\n\tvar U = UZIP.F.U, goodIndex = UZIP.F._goodIndex, hash = UZIP.F._hash, putsE = UZIP.F._putsE;\r\n\tvar i = 0, pos = opos<<3, cvrd = 0, dlen = data.length;\r\n\t\r\n\tif(lvl==0) {\r\n\t\twhile(i<dlen) {   var len = Math.min(0xffff, dlen-i);\r\n\t\t\tputsE(out, pos, (i+len==dlen ? 1 : 0));  pos = UZIP.F._copyExact(data, i, len, out, pos+8);  i += len;  }\r\n\t\treturn pos>>>3;\r\n\t}\r\n\r\n\tvar lits = U.lits, strt=U.strt, prev=U.prev, li=0, lc=0, bs=0, ebits=0, c=0, nc=0;  // last_item, literal_count, block_start\r\n\tif(dlen>2) {  nc=UZIP.F._hash(data,0);  strt[nc]=0;  }\r\n\tvar nmch=0,nmci=0;\r\n\t\r\n\tfor(i=0; i<dlen; i++)  {\r\n\t\tc = nc;\r\n\t\t//*\r\n\t\tif(i+1<dlen-2) {\r\n\t\t\tnc = UZIP.F._hash(data, i+1);\r\n\t\t\tvar ii = ((i+1)&0x7fff);\r\n\t\t\tprev[ii]=strt[nc];\r\n\t\t\tstrt[nc]=ii;\r\n\t\t} //*/\r\n\t\tif(cvrd<=i) {\r\n\t\t\tif((li>14000 || lc>26697) && (dlen-i)>100) {\r\n\t\t\t\tif(cvrd<i) {  lits[li]=i-cvrd;  li+=2;  cvrd=i;  }\r\n\t\t\t\tpos = UZIP.F._writeBlock(((i==dlen-1) || (cvrd==dlen))?1:0, lits, li, ebits, data,bs,i-bs, out, pos);  li=lc=ebits=0;  bs=i;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar mch = 0;\r\n\t\t\t//if(nmci==i) mch= nmch;  else \r\n\t\t\tif(i<dlen-2) mch = UZIP.F._bestMatch(data, i, prev, c, Math.min(opt[2],dlen-i), opt[3]);\r\n\t\t\t/*\r\n\t\t\tif(mch!=0 && opt[4]==1 && (mch>>>16)<opt[1] && i+1<dlen-2) {\r\n\t\t\t\tnmch = UZIP.F._bestMatch(data, i+1, prev, nc, opt[2], opt[3]);  nmci=i+1;\r\n\t\t\t\t//var mch2 = UZIP.F._bestMatch(data, i+2, prev, nnc);  //nmci=i+1;\r\n\t\t\t\tif((nmch>>>16)>(mch>>>16)) mch=0;\r\n\t\t\t}//*/\r\n\t\t\tvar len = mch>>>16, dst = mch&0xffff;  //if(i-dst<0) throw \"e\";\r\n\t\t\tif(mch!=0) { \r\n\t\t\t\tvar len = mch>>>16, dst = mch&0xffff;  //if(i-dst<0) throw \"e\";\r\n\t\t\t\tvar lgi = goodIndex(len, U.of0);  U.lhst[257+lgi]++; \r\n\t\t\t\tvar dgi = goodIndex(dst, U.df0);  U.dhst[    dgi]++;  ebits += U.exb[lgi] + U.dxb[dgi]; \r\n\t\t\t\tlits[li] = (len<<23)|(i-cvrd);  lits[li+1] = (dst<<16)|(lgi<<8)|dgi;  li+=2;\r\n\t\t\t\tcvrd = i + len;  \r\n\t\t\t}\r\n\t\t\telse {\tU.lhst[data[i]]++;  }\r\n\t\t\tlc++;\r\n\t\t}\r\n\t}\r\n\tif(bs!=i || data.length==0) {\r\n\t\tif(cvrd<i) {  lits[li]=i-cvrd;  li+=2;  cvrd=i;  }\r\n\t\tpos = UZIP.F._writeBlock(1, lits, li, ebits, data,bs,i-bs, out, pos);  li=0;  lc=0;  li=lc=ebits=0;  bs=i;\r\n\t}\r\n\twhile((pos&7)!=0) pos++;\r\n\treturn pos>>>3;\r\n}\r\nUZIP.F._bestMatch = function(data, i, prev, c, nice, chain) {\r\n\tvar ci = (i&0x7fff), pi=prev[ci];  \r\n\t//console.log(\"----\", i);\r\n\tvar dif = ((ci-pi + (1<<15)) & 0x7fff);  if(pi==ci || c!=UZIP.F._hash(data,i-dif)) return 0;\r\n\tvar tl=0, td=0;  // top length, top distance\r\n\tvar dlim = Math.min(0x7fff, i);\r\n\twhile(dif<=dlim && --chain!=0 && pi!=ci /*&& c==UZIP.F._hash(data,i-dif)*/) {\r\n\t\tif(tl==0 || (data[i+tl]==data[i+tl-dif])) {\r\n\t\t\tvar cl = UZIP.F._howLong(data, i, dif);\r\n\t\t\tif(cl>tl) {  \r\n\t\t\t\ttl=cl;  td=dif;  if(tl>=nice) break;    //* \r\n\t\t\t\tif(dif+2<cl) cl = dif+2;\r\n\t\t\t\tvar maxd = 0; // pi does not point to the start of the word\r\n\t\t\t\tfor(var j=0; j<cl-2; j++) {\r\n\t\t\t\t\tvar ei =  (i-dif+j+ (1<<15)) & 0x7fff;\r\n\t\t\t\t\tvar li = prev[ei];\r\n\t\t\t\t\tvar curd = (ei-li + (1<<15)) & 0x7fff;\r\n\t\t\t\t\tif(curd>maxd) {  maxd=curd;  pi = ei; }\r\n\t\t\t\t}  //*/\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tci=pi;  pi = prev[ci];\r\n\t\tdif += ((ci-pi + (1<<15)) & 0x7fff);\r\n\t}\r\n\treturn (tl<<16)|td;\r\n}\r\nUZIP.F._howLong = function(data, i, dif) {\r\n\tif(data[i]!=data[i-dif] || data[i+1]!=data[i+1-dif] || data[i+2]!=data[i+2-dif]) return 0;\r\n\tvar oi=i, l = Math.min(data.length, i+258);  i+=3;\r\n\t//while(i+4<l && data[i]==data[i-dif] && data[i+1]==data[i+1-dif] && data[i+2]==data[i+2-dif] && data[i+3]==data[i+3-dif]) i+=4;\r\n\twhile(i<l && data[i]==data[i-dif]) i++;\r\n\treturn i-oi;\r\n}\r\nUZIP.F._hash = function(data, i) {\r\n\treturn (((data[i]<<8) | data[i+1])+(data[i+2]<<4))&0xffff;\r\n\t//var hash_shift = 0, hash_mask = 255;\r\n\t//var h = data[i+1] % 251;\r\n\t//h = (((h << 8) + data[i+2]) % 251);\r\n\t//h = (((h << 8) + data[i+2]) % 251);\r\n\t//h = ((h<<hash_shift) ^ (c) ) & hash_mask;\r\n\t//return h | (data[i]<<8);\r\n\t//return (data[i] | (data[i+1]<<8));\r\n}\r\n//UZIP.___toth = 0;\r\nUZIP.saved = 0;\r\nUZIP.F._writeBlock = function(BFINAL, lits, li, ebits, data,o0,l0, out, pos) {\r\n\tvar U = UZIP.F.U, putsF = UZIP.F._putsF, putsE = UZIP.F._putsE;\r\n\t\r\n\t//*\r\n\tvar T, ML, MD, MH, numl, numd, numh, lset, dset;  U.lhst[256]++;\r\n\tT = UZIP.F.getTrees(); ML=T[0]; MD=T[1]; MH=T[2]; numl=T[3]; numd=T[4]; numh=T[5]; lset=T[6]; dset=T[7];\r\n\t\r\n\tvar cstSize = (((pos+3)&7)==0 ? 0 : 8-((pos+3)&7)) + 32 + (l0<<3);\r\n\tvar fxdSize = ebits + UZIP.F.contSize(U.fltree, U.lhst) + UZIP.F.contSize(U.fdtree, U.dhst);\r\n\tvar dynSize = ebits + UZIP.F.contSize(U.ltree , U.lhst) + UZIP.F.contSize(U.dtree , U.dhst);\r\n\tdynSize    += 14 + 3*numh + UZIP.F.contSize(U.itree, U.ihst) + (U.ihst[16]*2 + U.ihst[17]*3 + U.ihst[18]*7);\r\n\t\r\n\tfor(var j=0; j<286; j++) U.lhst[j]=0;   for(var j=0; j<30; j++) U.dhst[j]=0;   for(var j=0; j<19; j++) U.ihst[j]=0;\r\n\t//*/\r\n\tvar BTYPE = (cstSize<fxdSize && cstSize<dynSize) ? 0 : ( fxdSize<dynSize ? 1 : 2 );\r\n\tputsF(out, pos, BFINAL);  putsF(out, pos+1, BTYPE);  pos+=3;\r\n\t\r\n\tvar opos = pos;\r\n\tif(BTYPE==0) {\r\n\t\twhile((pos&7)!=0) pos++;\r\n\t\tpos = UZIP.F._copyExact(data, o0, l0, out, pos);\r\n\t}\r\n\telse {\r\n\t\tvar ltree, dtree;\r\n\t\tif(BTYPE==1) {  ltree=U.fltree;  dtree=U.fdtree;  }\r\n\t\tif(BTYPE==2) {\t\r\n\t\t\tUZIP.F.makeCodes(U.ltree, ML);  UZIP.F.revCodes(U.ltree, ML);\r\n\t\t\tUZIP.F.makeCodes(U.dtree, MD);  UZIP.F.revCodes(U.dtree, MD);\r\n\t\t\tUZIP.F.makeCodes(U.itree, MH);  UZIP.F.revCodes(U.itree, MH);\r\n\t\t\t\r\n\t\t\tltree = U.ltree;  dtree = U.dtree;\r\n\t\t\t\r\n\t\t\tputsE(out, pos,numl-257);  pos+=5;  // 286\r\n\t\t\tputsE(out, pos,numd-  1);  pos+=5;  // 30\r\n\t\t\tputsE(out, pos,numh-  4);  pos+=4;  // 19\r\n\t\t\t\r\n\t\t\tfor(var i=0; i<numh; i++) putsE(out, pos+i*3, U.itree[(U.ordr[i]<<1)+1]);   pos+=3* numh;\r\n\t\t\tpos = UZIP.F._codeTiny(lset, U.itree, out, pos);\r\n\t\t\tpos = UZIP.F._codeTiny(dset, U.itree, out, pos);\r\n\t\t}\r\n\t\t\r\n\t\tvar off=o0;\r\n\t\tfor(var si=0; si<li; si+=2) {\r\n\t\t\tvar qb=lits[si], len=(qb>>>23), end = off+(qb&((1<<23)-1));\r\n\t\t\twhile(off<end) pos = UZIP.F._writeLit(data[off++], ltree, out, pos);\r\n\t\t\t\r\n\t\t\tif(len!=0) {\r\n\t\t\t\tvar qc = lits[si+1], dst=(qc>>16), lgi=(qc>>8)&255, dgi=(qc&255);\r\n\t\t\t\tpos = UZIP.F._writeLit(257+lgi, ltree, out, pos);\r\n\t\t\t\tputsE(out, pos, len-U.of0[lgi]);  pos+=U.exb[lgi];\r\n\t\t\t\t\r\n\t\t\t\tpos = UZIP.F._writeLit(dgi, dtree, out, pos);\r\n\t\t\t\tputsF(out, pos, dst-U.df0[dgi]);  pos+=U.dxb[dgi];  off+=len;\r\n\t\t\t}\r\n\t\t}\r\n\t\tpos = UZIP.F._writeLit(256, ltree, out, pos);\r\n\t}\r\n\t//console.log(pos-opos, fxdSize, dynSize, cstSize);\r\n\treturn pos;\r\n}\r\nUZIP.F._copyExact = function(data,off,len,out,pos) {\r\n\tvar p8 = (pos>>>3);\r\n\tout[p8]=(len);  out[p8+1]=(len>>>8);  out[p8+2]=255-out[p8];  out[p8+3]=255-out[p8+1];  p8+=4;\r\n\tout.set(new Uint8Array(data.buffer, off, len), p8);\r\n\t//for(var i=0; i<len; i++) out[p8+i]=data[off+i];\r\n\treturn pos + ((len+4)<<3);\r\n}\r\n/*\r\n\tInteresting facts:\r\n\t- decompressed block can have bytes, which do not occur in a Huffman tree (copied from the previous block by reference)\r\n*/\r\n\r\nUZIP.F.getTrees = function() {\r\n\tvar U = UZIP.F.U;\r\n\tvar ML = UZIP.F._hufTree(U.lhst, U.ltree, 15);\r\n\tvar MD = UZIP.F._hufTree(U.dhst, U.dtree, 15);\r\n\tvar lset = [], numl = UZIP.F._lenCodes(U.ltree, lset);\r\n\tvar dset = [], numd = UZIP.F._lenCodes(U.dtree, dset);\r\n\tfor(var i=0; i<lset.length; i+=2) U.ihst[lset[i]]++;\r\n\tfor(var i=0; i<dset.length; i+=2) U.ihst[dset[i]]++;\r\n\tvar MH = UZIP.F._hufTree(U.ihst, U.itree,  7);\r\n\tvar numh = 19;  while(numh>4 && U.itree[(U.ordr[numh-1]<<1)+1]==0) numh--;\r\n\treturn [ML, MD, MH, numl, numd, numh, lset, dset];\r\n}\r\nUZIP.F.getSecond= function(a) {  var b=[];  for(var i=0; i<a.length; i+=2) b.push  (a[i+1]);  return b;  }\r\nUZIP.F.nonZero  = function(a) {  var b= \"\";  for(var i=0; i<a.length; i+=2) if(a[i+1]!=0)b+=(i>>1)+\",\";  return b;  }\r\nUZIP.F.contSize = function(tree, hst) {  var s=0;  for(var i=0; i<hst.length; i++) s+= hst[i]*tree[(i<<1)+1];  return s;  }\r\nUZIP.F._codeTiny = function(set, tree, out, pos) {\r\n\tfor(var i=0; i<set.length; i+=2) {\r\n\t\tvar l = set[i], rst = set[i+1];  //console.log(l, pos, tree[(l<<1)+1]);\r\n\t\tpos = UZIP.F._writeLit(l, tree, out, pos);\r\n\t\tvar rsl = l==16 ? 2 : (l==17 ? 3 : 7);\r\n\t\tif(l>15) {  UZIP.F._putsE(out, pos, rst, rsl);  pos+=rsl;  }\r\n\t}\r\n\treturn pos;\r\n}\r\nUZIP.F._lenCodes = function(tree, set) {\r\n\tvar len=tree.length;  while(len!=2 && tree[len-1]==0) len-=2;  // when no distances, keep one code with length 0\r\n\tfor(var i=0; i<len; i+=2) {\r\n\t\tvar l = tree[i+1], nxt = (i+3<len ? tree[i+3]:-1),  nnxt = (i+5<len ? tree[i+5]:-1),  prv = (i==0 ? -1 : tree[i-1]);\r\n\t\tif(l==0 && nxt==l && nnxt==l) {\r\n\t\t\tvar lz = i+5;\r\n\t\t\twhile(lz+2<len && tree[lz+2]==l) lz+=2;\r\n\t\t\tvar zc = Math.min((lz+1-i)>>>1, 138);\r\n\t\t\tif(zc<11) set.push(17, zc-3);\r\n\t\t\telse set.push(18, zc-11);\r\n\t\t\ti += zc*2-2;\r\n\t\t}\r\n\t\telse if(l==prv && nxt==l && nnxt==l) {\r\n\t\t\tvar lz = i+5;\r\n\t\t\twhile(lz+2<len && tree[lz+2]==l) lz+=2;\r\n\t\t\tvar zc = Math.min((lz+1-i)>>>1, 6);\r\n\t\t\tset.push(16, zc-3);\r\n\t\t\ti += zc*2-2;\r\n\t\t}\r\n\t\telse set.push(l, 0);\r\n\t}\r\n\treturn len>>>1;\r\n}\r\nUZIP.F._hufTree   = function(hst, tree, MAXL) {\r\n\tvar list=[], hl = hst.length, tl=tree.length, i=0;\r\n\tfor(i=0; i<tl; i+=2) {  tree[i]=0;  tree[i+1]=0;  }\t\r\n\tfor(i=0; i<hl; i++) if(hst[i]!=0) list.push({lit:i, f:hst[i]});\r\n\tvar end = list.length, l2=list.slice(0);\r\n\tif(end==0) return 0;  // empty histogram (usually for dist)\r\n\tif(end==1) {  var lit=list[0].lit, l2=lit==0?1:0;  tree[(lit<<1)+1]=1;  tree[(l2<<1)+1]=1;  return 1;  }\r\n\tlist.sort(function(a,b){return a.f-b.f;});\r\n\tvar a=list[0], b=list[1], i0=0, i1=1, i2=2;  list[0]={lit:-1,f:a.f+b.f,l:a,r:b,d:0};\r\n\twhile(i1!=end-1) {\r\n\t\tif(i0!=i1 && (i2==end || list[i0].f<list[i2].f)) {  a=list[i0++];  }  else {  a=list[i2++];  }\r\n\t\tif(i0!=i1 && (i2==end || list[i0].f<list[i2].f)) {  b=list[i0++];  }  else {  b=list[i2++];  }\r\n\t\tlist[i1++]={lit:-1,f:a.f+b.f, l:a,r:b};\r\n\t}\r\n\tvar maxl = UZIP.F.setDepth(list[i1-1], 0);\r\n\tif(maxl>MAXL) {  UZIP.F.restrictDepth(l2, MAXL, maxl);  maxl = MAXL;  }\r\n\tfor(i=0; i<end; i++) tree[(l2[i].lit<<1)+1]=l2[i].d;\r\n\treturn maxl;\r\n}\r\n\r\nUZIP.F.setDepth  = function(t, d) {\r\n\tif(t.lit!=-1) {  t.d=d;  return d;  }\r\n\treturn Math.max( UZIP.F.setDepth(t.l, d+1),  UZIP.F.setDepth(t.r, d+1) );\r\n}\r\n\r\nUZIP.F.restrictDepth = function(dps, MD, maxl) {\r\n\tvar i=0, bCost=1<<(maxl-MD), dbt=0;\r\n\tdps.sort(function(a,b){return b.d==a.d ? a.f-b.f : b.d-a.d;});\r\n\t\r\n\tfor(i=0; i<dps.length; i++) if(dps[i].d>MD) {  var od=dps[i].d;  dps[i].d=MD;  dbt+=bCost-(1<<(maxl-od));  }  else break;\r\n\tdbt = dbt>>>(maxl-MD);\r\n\twhile(dbt>0) {  var od=dps[i].d;  if(od<MD) {  dps[i].d++;  dbt-=(1<<(MD-od-1));  }  else  i++;  }\r\n\tfor(; i>=0; i--) if(dps[i].d==MD && dbt<0) {  dps[i].d--;  dbt++;  }  if(dbt!=0) console.log(\"debt left\");\r\n}\r\n\r\nUZIP.F._goodIndex = function(v, arr) {\r\n\tvar i=0;  if(arr[i|16]<=v) i|=16;  if(arr[i|8]<=v) i|=8;  if(arr[i|4]<=v) i|=4;  if(arr[i|2]<=v) i|=2;  if(arr[i|1]<=v) i|=1;  return i;\r\n}\r\nUZIP.F._writeLit = function(ch, ltree, out, pos) {\r\n\tUZIP.F._putsF(out, pos, ltree[ch<<1]);\r\n\treturn pos+ltree[(ch<<1)+1];\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nUZIP.F.inflate = function(data, buf) {\r\n\tvar u8=Uint8Array;\r\n\tif(data[0]==3 && data[1]==0) return (buf ? buf : new u8(0));\r\n\tvar F=UZIP.F, bitsF = F._bitsF, bitsE = F._bitsE, decodeTiny = F._decodeTiny, makeCodes = F.makeCodes, codes2map=F.codes2map, get17 = F._get17;\r\n\tvar U = F.U;\r\n\t\r\n\tvar noBuf = (buf==null);\r\n\tif(noBuf) buf = new u8((data.length>>>2)<<3);\r\n\t\r\n\tvar BFINAL=0, BTYPE=0, HLIT=0, HDIST=0, HCLEN=0, ML=0, MD=0; \t\r\n\tvar off = 0, pos = 0;\r\n\tvar lmap, dmap;\r\n\t\r\n\twhile(BFINAL==0) {\t\t\r\n\t\tBFINAL = bitsF(data, pos  , 1);\r\n\t\tBTYPE  = bitsF(data, pos+1, 2);  pos+=3;\r\n\t\t//console.log(BFINAL, BTYPE);\r\n\t\t\r\n\t\tif(BTYPE==0) {\r\n\t\t\tif((pos&7)!=0) pos+=8-(pos&7);\r\n\t\t\tvar p8 = (pos>>>3)+4, len = data[p8-4]|(data[p8-3]<<8);  //console.log(len);//bitsF(data, pos, 16), \r\n\t\t\tif(noBuf) buf=UZIP.F._check(buf, off+len);\r\n\t\t\tbuf.set(new u8(data.buffer, data.byteOffset+p8, len), off);\r\n\t\t\t//for(var i=0; i<len; i++) buf[off+i] = data[p8+i];\r\n\t\t\t//for(var i=0; i<len; i++) if(buf[off+i] != data[p8+i]) throw \"e\";\r\n\t\t\tpos = ((p8+len)<<3);  off+=len;  continue;\r\n\t\t}\r\n\t\tif(noBuf) buf=UZIP.F._check(buf, off+(1<<17));  // really not enough in many cases (but PNG and ZIP provide buffer in advance)\r\n\t\tif(BTYPE==1) {  lmap = U.flmap;  dmap = U.fdmap;  ML = (1<<9)-1;  MD = (1<<5)-1;   }\r\n\t\tif(BTYPE==2) {\r\n\t\t\tHLIT  = bitsE(data, pos   , 5)+257;  \r\n\t\t\tHDIST = bitsE(data, pos+ 5, 5)+  1;  \r\n\t\t\tHCLEN = bitsE(data, pos+10, 4)+  4;  pos+=14;\r\n\t\t\t\r\n\t\t\tvar ppos = pos;\r\n\t\t\tfor(var i=0; i<38; i+=2) {  U.itree[i]=0;  U.itree[i+1]=0;  }\r\n\t\t\tvar tl = 1;\r\n\t\t\tfor(var i=0; i<HCLEN; i++) {  var l=bitsE(data, pos+i*3, 3);  U.itree[(U.ordr[i]<<1)+1] = l;  if(l>tl)tl=l;  }     pos+=3*HCLEN;  //console.log(itree);\r\n\t\t\tmakeCodes(U.itree, tl);\r\n\t\t\tcodes2map(U.itree, tl, U.imap);\r\n\t\t\t\r\n\t\t\tlmap = U.lmap;  dmap = U.dmap;\r\n\t\t\t\r\n\t\t\tpos = decodeTiny(U.imap, (1<<tl)-1, HLIT+HDIST, data, pos, U.ttree);\r\n\t\t\tvar mx0 = F._copyOut(U.ttree,    0, HLIT , U.ltree);  ML = (1<<mx0)-1;\r\n\t\t\tvar mx1 = F._copyOut(U.ttree, HLIT, HDIST, U.dtree);  MD = (1<<mx1)-1;\r\n\t\t\t\r\n\t\t\t//var ml = decodeTiny(U.imap, (1<<tl)-1, HLIT , data, pos, U.ltree); ML = (1<<(ml>>>24))-1;  pos+=(ml&0xffffff);\r\n\t\t\tmakeCodes(U.ltree, mx0);\r\n\t\t\tcodes2map(U.ltree, mx0, lmap);\r\n\t\t\t\r\n\t\t\t//var md = decodeTiny(U.imap, (1<<tl)-1, HDIST, data, pos, U.dtree); MD = (1<<(md>>>24))-1;  pos+=(md&0xffffff);\r\n\t\t\tmakeCodes(U.dtree, mx1);\r\n\t\t\tcodes2map(U.dtree, mx1, dmap);\r\n\t\t}\r\n\t\t//var ooff=off, opos=pos;\r\n\t\twhile(true) {\r\n\t\t\tvar code = lmap[get17(data, pos) & ML];  pos += code&15;\r\n\t\t\tvar lit = code>>>4;  //U.lhst[lit]++;  \r\n\t\t\tif((lit>>>8)==0) {  buf[off++] = lit;  }\r\n\t\t\telse if(lit==256) {  break;  }\r\n\t\t\telse {\r\n\t\t\t\tvar end = off+lit-254;\r\n\t\t\t\tif(lit>264) { var ebs = U.ldef[lit-257];  end = off + (ebs>>>3) + bitsE(data, pos, ebs&7);  pos += ebs&7;  }\r\n\t\t\t\t//UZIP.F.dst[end-off]++;\r\n\t\t\t\t\r\n\t\t\t\tvar dcode = dmap[get17(data, pos) & MD];  pos += dcode&15;\r\n\t\t\t\tvar dlit = dcode>>>4;\r\n\t\t\t\tvar dbs = U.ddef[dlit], dst = (dbs>>>4) + bitsF(data, pos, dbs&15);  pos += dbs&15;\r\n\t\t\t\t\r\n\t\t\t\t//var o0 = off-dst, stp = Math.min(end-off, dst);\r\n\t\t\t\t//if(stp>20) while(off<end) {  buf.copyWithin(off, o0, o0+stp);  off+=stp;  }  else\r\n\t\t\t\t//if(end-dst<=off) buf.copyWithin(off, off-dst, end-dst);  else\r\n\t\t\t\t//if(dst==1) buf.fill(buf[off-1], off, end);  else\r\n\t\t\t\tif(noBuf) buf=UZIP.F._check(buf, off+(1<<17));\r\n\t\t\t\twhile(off<end) {  buf[off]=buf[off++-dst];    buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  }   \r\n\t\t\t\toff=end;\r\n\t\t\t\t//while(off!=end) {  buf[off]=buf[off++-dst];  }\r\n\t\t\t}\r\n\t\t}\r\n\t\t//console.log(off-ooff, (pos-opos)>>>3);\r\n\t}\r\n\t//console.log(UZIP.F.dst);\r\n\t//console.log(tlen, dlen, off-tlen+tcnt);\r\n\treturn buf.length==off ? buf : buf.slice(0,off);\r\n}\r\nUZIP.F._check=function(buf, len) {\r\n\tvar bl=buf.length;  if(len<=bl) return buf;\r\n\tvar nbuf = new Uint8Array(Math.max(bl<<1,len));  nbuf.set(buf,0);\r\n\t//for(var i=0; i<bl; i+=4) {  nbuf[i]=buf[i];  nbuf[i+1]=buf[i+1];  nbuf[i+2]=buf[i+2];  nbuf[i+3]=buf[i+3];  }\r\n\treturn nbuf;\r\n}\r\n\r\nUZIP.F._decodeTiny = function(lmap, LL, len, data, pos, tree) {\r\n\tvar bitsE = UZIP.F._bitsE, get17 = UZIP.F._get17;\r\n\tvar i = 0;\r\n\twhile(i<len) {\r\n\t\tvar code = lmap[get17(data, pos)&LL];  pos+=code&15;\r\n\t\tvar lit = code>>>4; \r\n\t\tif(lit<=15) {  tree[i]=lit;  i++;  }\r\n\t\telse {\r\n\t\t\tvar ll = 0, n = 0;\r\n\t\t\tif(lit==16) {\r\n\t\t\t\tn = (3  + bitsE(data, pos, 2));  pos += 2;  ll = tree[i-1];\r\n\t\t\t}\r\n\t\t\telse if(lit==17) {\r\n\t\t\t\tn = (3  + bitsE(data, pos, 3));  pos += 3;\r\n\t\t\t}\r\n\t\t\telse if(lit==18) {\r\n\t\t\t\tn = (11 + bitsE(data, pos, 7));  pos += 7;\r\n\t\t\t}\r\n\t\t\tvar ni = i+n;\r\n\t\t\twhile(i<ni) {  tree[i]=ll;  i++; }\r\n\t\t}\r\n\t}\r\n\treturn pos;\r\n}\r\nUZIP.F._copyOut = function(src, off, len, tree) {\r\n\tvar mx=0, i=0, tl=tree.length>>>1;\r\n\twhile(i<len) {  var v=src[i+off];  tree[(i<<1)]=0;  tree[(i<<1)+1]=v;  if(v>mx)mx=v;  i++;  }\r\n\twhile(i<tl ) {  tree[(i<<1)]=0;  tree[(i<<1)+1]=0;  i++;  }\r\n\treturn mx;\r\n}\r\n\r\nUZIP.F.makeCodes = function(tree, MAX_BITS) {  // code, length\r\n\tvar U = UZIP.F.U;\r\n\tvar max_code = tree.length;\r\n\tvar code, bits, n, i, len;\r\n\t\r\n\tvar bl_count = U.bl_count;  for(var i=0; i<=MAX_BITS; i++) bl_count[i]=0;\r\n\tfor(i=1; i<max_code; i+=2) bl_count[tree[i]]++;\r\n\t\r\n\tvar next_code = U.next_code;\t// smallest code for each length\r\n\t\r\n\tcode = 0;\r\n\tbl_count[0] = 0;\r\n\tfor (bits = 1; bits <= MAX_BITS; bits++) {\r\n\t\tcode = (code + bl_count[bits-1]) << 1;\r\n\t\tnext_code[bits] = code;\r\n\t}\r\n\t\r\n\tfor (n = 0; n < max_code; n+=2) {\r\n\t\tlen = tree[n+1];\r\n\t\tif (len != 0) {\r\n\t\t\ttree[n] = next_code[len];\r\n\t\t\tnext_code[len]++;\r\n\t\t}\r\n\t}\r\n}\r\nUZIP.F.codes2map = function(tree, MAX_BITS, map) {\r\n\tvar max_code = tree.length;\r\n\tvar U=UZIP.F.U, r15 = U.rev15;\r\n\tfor(var i=0; i<max_code; i+=2) if(tree[i+1]!=0)  {\r\n\t\tvar lit = i>>1;\r\n\t\tvar cl = tree[i+1], val = (lit<<4)|cl; // :  (0x8000 | (U.of0[lit-257]<<7) | (U.exb[lit-257]<<4) | cl);\r\n\t\tvar rest = (MAX_BITS-cl), i0 = tree[i]<<rest, i1 = i0 + (1<<rest);\r\n\t\t//tree[i]=r15[i0]>>>(15-MAX_BITS);\r\n\t\twhile(i0!=i1) {\r\n\t\t\tvar p0 = r15[i0]>>>(15-MAX_BITS);\r\n\t\t\tmap[p0]=val;  i0++;\r\n\t\t}\r\n\t}\r\n}\r\nUZIP.F.revCodes = function(tree, MAX_BITS) {\r\n\tvar r15 = UZIP.F.U.rev15, imb = 15-MAX_BITS;\r\n\tfor(var i=0; i<tree.length; i+=2) {  var i0 = (tree[i]<<(MAX_BITS-tree[i+1]));  tree[i] = r15[i0]>>>imb;  }\r\n}\r\n\r\n// used only in deflate\r\nUZIP.F._putsE= function(dt, pos, val   ) {  val = val<<(pos&7);  var o=(pos>>>3);  dt[o]|=val;  dt[o+1]|=(val>>>8);                        }\r\nUZIP.F._putsF= function(dt, pos, val   ) {  val = val<<(pos&7);  var o=(pos>>>3);  dt[o]|=val;  dt[o+1]|=(val>>>8);  dt[o+2]|=(val>>>16);  }\r\n\r\nUZIP.F._bitsE= function(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8)                        )>>>(pos&7))&((1<<length)-1);  }\r\nUZIP.F._bitsF= function(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16))>>>(pos&7))&((1<<length)-1);  }\r\n/*\r\nUZIP.F._get9 = function(dt, pos) {\r\n\treturn ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8))>>>(pos&7))&511;\r\n} */\r\nUZIP.F._get17= function(dt, pos) {\t// return at least 17 meaningful bytes\r\n\treturn (dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16) )>>>(pos&7);\r\n}\r\nUZIP.F._get25= function(dt, pos) {\t// return at least 17 meaningful bytes\r\n\treturn (dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16) | (dt[(pos>>>3)+3]<<24) )>>>(pos&7);\r\n}\r\nUZIP.F.U = function(){\r\n\tvar u16=Uint16Array, u32=Uint32Array;\r\n\treturn {\r\n\t\tnext_code : new u16(16),\r\n\t\tbl_count  : new u16(16),\r\n\t\tordr : [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ],\r\n\t\tof0  : [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],\r\n\t\texb  : [0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0,  0,  0,  0],\r\n\t\tldef : new u16(32),\r\n\t\tdf0  : [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 65535, 65535],\r\n\t\tdxb  : [0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,     0,     0],\r\n\t\tddef : new u32(32),\r\n\t\tflmap: new u16(  512),  fltree: [],\r\n\t\tfdmap: new u16(   32),  fdtree: [],\r\n\t\tlmap : new u16(32768),  ltree : [],  ttree:[],\r\n\t\tdmap : new u16(32768),  dtree : [],\r\n\t\timap : new u16(  512),  itree : [],\r\n\t\t//rev9 : new u16(  512)\r\n\t\trev15: new u16(1<<15),\r\n\t\tlhst : new u32(286), dhst : new u32( 30), ihst : new u32(19),\r\n\t\tlits : new u32(15000),\r\n\t\tstrt : new u16(1<<16),\r\n\t\tprev : new u16(1<<15)\r\n\t};  \r\n} ();\r\n\r\n(function(){\t\r\n\tvar U = UZIP.F.U;\r\n\tvar len = 1<<15;\r\n\tfor(var i=0; i<len; i++) {\r\n\t\tvar x = i;\r\n\t\tx = (((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1));\r\n\t\tx = (((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2));\r\n\t\tx = (((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4));\r\n\t\tx = (((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8));\r\n\t\tU.rev15[i] = (((x >>> 16) | (x << 16)))>>>17;\r\n\t}\r\n\t\r\n\tfunction pushV(tgt, n, sv) {  while(n--!=0) tgt.push(0,sv);  }\r\n\t\r\n\tfor(var i=0; i<32; i++) {  U.ldef[i]=(U.of0[i]<<3)|U.exb[i];  U.ddef[i]=(U.df0[i]<<4)|U.dxb[i];  }\r\n\t\r\n\tpushV(U.fltree, 144, 8);  pushV(U.fltree, 255-143, 9);  pushV(U.fltree, 279-255, 7);  pushV(U.fltree,287-279,8);\r\n\t/*\r\n\tvar i = 0;\r\n\tfor(; i<=143; i++) U.fltree.push(0,8);\r\n\tfor(; i<=255; i++) U.fltree.push(0,9);\r\n\tfor(; i<=279; i++) U.fltree.push(0,7);\r\n\tfor(; i<=287; i++) U.fltree.push(0,8);\r\n\t*/\r\n\tUZIP.F.makeCodes(U.fltree, 9);\r\n\tUZIP.F.codes2map(U.fltree, 9, U.flmap);\r\n\tUZIP.F.revCodes (U.fltree, 9)\r\n\t\r\n\tpushV(U.fdtree,32,5);\r\n\t//for(i=0;i<32; i++) U.fdtree.push(0,5);\r\n\tUZIP.F.makeCodes(U.fdtree, 5);\r\n\tUZIP.F.codes2map(U.fdtree, 5, U.fdmap);\r\n\tUZIP.F.revCodes (U.fdtree, 5)\r\n\t\r\n\tpushV(U.itree,19,0);  pushV(U.ltree,286,0);  pushV(U.dtree,30,0);  pushV(U.ttree,320,0);\r\n\t/*\r\n\tfor(var i=0; i< 19; i++) U.itree.push(0,0);\r\n\tfor(var i=0; i<286; i++) U.ltree.push(0,0);\r\n\tfor(var i=0; i< 30; i++) U.dtree.push(0,0);\r\n\tfor(var i=0; i<320; i++) U.ttree.push(0,0);\r\n\t*/\r\n})()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","<script lang=\"ts\">\r\n    import uzip from \"uzip\";\r\n\r\n    let finalText = \"\";\r\n\r\n    type states = \"idle\" | \"dragging\" | \"dropped\";\r\n    let state: states = \"idle\";\r\n\r\n    const dp = new DOMParser();\r\n    const utf8decoder = new TextDecoder();\r\n\r\n    function parseXML(input: string) {\r\n        function getLineText(node: HTMLParagraphElement) {\r\n            const words = node.childNodes;\r\n            let finalText = \"\";\r\n\r\n            words.forEach(\r\n                (\r\n                    element: Element & { tagName: string; textContent: string }\r\n                ) => {\r\n                    // if (element.tagName === \"a:r\") finalText += element.textContent;\r\n                    // else\r\n                    if (element.tagName === \"a:br\") finalText += \"\\n\";\r\n                    else finalText += element.textContent;\r\n                }\r\n            );\r\n            return finalText;\r\n        }\r\n\r\n        let output = \"\";\r\n        const xmldoc = dp.parseFromString(input, \"text/xml\");\r\n        xmldoc.querySelectorAll(\"p\").forEach((entry) => {\r\n            output += getLineText(entry).trim() + \"\\n\";\r\n        });\r\n        return output;\r\n    }\r\n\r\n    function handleInputFile(e: Event) {\r\n        const file = (e.target as HTMLInputElement).files[0];\r\n        state = \"dropped\";\r\n        loadFile(file);\r\n    }\r\n\r\n    async function loadFile(file: File) {\r\n        finalText = \"\";\r\n\r\n        const files = uzip.parse(await file.arrayBuffer());\r\n\r\n        const howManyFiles = Object.keys(files).filter(\r\n            (entry) => entry.indexOf(\"ppt/slides/slide\") !== -1\r\n        ).length;\r\n\r\n        for (let index = 1; index <= howManyFiles; index++) {\r\n            const buffer = files[\"ppt/slides/slide\" + index + \".xml\"];\r\n            const content = utf8decoder.decode(buffer);\r\n            finalText += parseXML(content);\r\n        }\r\n    }\r\n</script>\r\n\r\n<style>\r\n    main {\r\n        position: absolute;\r\n        left: 5vw;\r\n        top: 5vh;\r\n        width: 90%;\r\n        height: 90%;\r\n        border-radius: 10px;\r\n        text-align: center;\r\n        border: 4px dotted rgb(184, 184, 184);\r\n        background-color: rgba(143, 143, 143, 0.39);\r\n        z-index: 1;\r\n\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: center;\r\n        flex-direction: column;\r\n\r\n        transition: background-color 200ms, border 200ms, opacity 200ms;\r\n    }\r\n    main.dragging {\r\n        border: 4px dotted rgb(235, 185, 76);\r\n        background-color: rgba(238, 205, 20, 0.6);\r\n    }\r\n\r\n    main.dropped {\r\n        opacity: 0;\r\n    }\r\n\r\n    .post-select {\r\n        opacity: 0;\r\n        transition: opacity 200ms;\r\n    }\r\n    .post-select.dropped {\r\n        opacity: 1;\r\n    }\r\n</style>\r\n\r\n<main\r\n    class={state}\r\n    on:dragover|preventDefault={() => (state = 'dragging')}\r\n    on:dragleave|preventDefault={() => (state = 'idle')}\r\n    on:drop|preventDefault={(e) => {\r\n        loadFile(e.dataTransfer.files[0]);\r\n        state = 'dropped';\r\n    }}>\r\n    <h1>PPTX to TXT</h1>\r\n\r\n    <div class=\"text\">\r\n        {state === 'dragging' ? 'Solte' : 'Arraste'}\r\n        um arquivo .pptx para converter em texto.\r\n    </div>\r\n\r\n    <input type=\"file\" on:change={handleInputFile} accept=\".pptx\" />\r\n</main>\r\n\r\n<section class=\"post-select {state}\">\r\n    <h2>Aqui está o texto</h2>\r\n    <p>Arraste ou selecione outro arquivo para converter</p>\r\n\r\n    <input type=\"file\" on:change={handleInputFile} accept=\".pptx\" />\r\n    <hr />\r\n\r\n    <pre>{finalText}</pre>\r\n</section>\r\n","import App from './Convert.svelte';\n\nconst app = new App({\n\ttarget: document.body,\n});\n\nexport default app;"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","null_to_empty","value","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","element","name","document","createElement","text","data","createTextNode","space","listen","event","handler","options","addEventListener","removeEventListener","prevent_default","preventDefault","call","this","attr","attribute","removeAttribute","getAttribute","setAttribute","set_data","wholeText","current_component","set_current_component","component","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","push","flushing","seen_callbacks","Set","flush","i","length","update","$$","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","make_dirty","then","fill","init","instance","create_fragment","not_equal","props","parent_component","prop_values","bound","on_mount","on_destroy","context","Map","callbacks","skip_bound","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","c","intro","block","delete","local","m","new_on_destroy","map","filter","mount_component","u16","u32","UZIP","module","buf","onlyNames","rUs","bin","readUshort","rUi","readUint","o","out","Uint8Array","eocd","cnu","csize","coffs","usize","nl","el","cl","roff","_readLocal","cmpr","nlen","elen","readUTF8","size","file","buffer","slice","inflateRaw","F","inflate","byteOffset","deflate","opts","level","off","Math","floor","deflateRaw","crc","adler","encode","obj","noCmpr","tot","wUi","writeUint","wUs","writeUshort","zpd","cpr","_noNeed","sizeUTF8","fof","_writeHeader","ioff","ext","split","toLowerCase","indexOf","t","writeUTF8","set","table","tab","Uint32Array","n","k","len","end","eend","min","buff","readASCII","s","String","fromCharCode","writeASCII","charCodeAt","pad","ns","toString","decodeURIComponent","e","str","strl","ci","code","opos","lvl","opt","U","goodIndex","_goodIndex","putsE","_hash","_putsE","pos","cvrd","dlen","_copyExact","lits","strt","prev","li","lc","bs","ebits","nc","ii","_writeBlock","mch","_bestMatch","dst","lgi","of0","lhst","dgi","df0","dhst","exb","dxb","nice","chain","pi","dif","tl","td","dlim","_howLong","maxd","j","ei","curd","oi","saved","BFINAL","o0","l0","T","ML","MD","MH","numl","numd","numh","lset","dset","putsF","_putsF","getTrees","cstSize","fxdSize","contSize","fltree","fdtree","dynSize","ltree","dtree","itree","ihst","BTYPE","makeCodes","revCodes","ordr","_codeTiny","si","qb","_writeLit","qc","p8","_hufTree","_lenCodes","getSecond","nonZero","tree","hst","rst","rsl","nxt","nnxt","prv","lz","zc","MAXL","list","hl","lit","f","l2","sort","i0","i1","i2","r","d","maxl","setDepth","restrictDepth","max","dps","bCost","dbt","od","console","log","v","arr","ch","u8","bitsF","_bitsF","bitsE","_bitsE","decodeTiny","_decodeTiny","codes2map","get17","_get17","noBuf","lmap","dmap","HLIT","HDIST","HCLEN","_check","flmap","fdmap","imap","ttree","mx0","_copyOut","mx1","ebs","ldef","dcode","dlit","dbs","ddef","bl","nbuf","LL","ll","ni","src","mx","MAX_BITS","bits","max_code","bl_count","next_code","r15","rev15","val","imb","dt","_get25","Uint16Array","x","pushV","tgt","sv","__awaiter","thisArg","_arguments","P","generator","reject","fulfilled","step","next","rejected","result","done","apply","finalText","state","dp","DOMParser","utf8decoder","TextDecoder","parseXML","input","output","parseFromString","querySelectorAll","entry","words","tagName","textContent","getLineText","trim","loadFile","files","uzip","parse","arrayBuffer","howManyFiles","keys","index","content","decode","dataTransfer","[object Object]","detaching","destroy_component","$destroy","type","splice","$$props","$$set","body"],"mappings":"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"}